import StyleDictionary from "style-dictionary";
import fs from "fs";
import path from "path";
import { FormatterArguments } from "style-dictionary/types/Format";
import { extractThemes } from "./utils/extractThemes";
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { Config } from "style-dictionary";

import { writeToFile } from "./utils/WriteToFile";
import { removeSuffix } from "./utils/stringUtils";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

type TokenValue = string | Record<string, unknown>;

type Token = {
    value?: TokenValue;
    type?: string;
    description?: string;
    [key: string]: TokenValue | string | undefined;
};

type Section = Record<string, Token> | string[];

export type Theme = Record<string, Section> | string[];

export type DesignTokensFigma<T extends Record<string, unknown> = Record<string, unknown>> = {
    [theme: string]: Theme;
} & {
    $themes: string[]; // Update the type of $themes property to string[]
    $metadata: {
        tokenSetOrder: string[];
    };
};

/**
 * The path the Figma Design Tokens are saved to
 */
const getSourceJsonPath = (): string => path.join(__dirname, "../rh_tokens/tokens.json");

/**
 * The path to save the Design Tokens parsed from the main Design Tokens from Token Studio for Figma
 * @returns {string}
 */
const getDirectoryPath = (): string => path.join(__dirname, "../design_token_converted");
const getExportsDirectoryPath = (directory: string, filename: string): string => `${path.join(__dirname, "../design_token_exports")}/${directory}/${filename}/`;


/**
 * Takes the auto-generated .json from Token Studio for Figma and extracts the top level key/value element, 
 * writing them to the file system and naming them as per they key with content as per the JSON content of the value. 
 * @param {string} jPath - the path to save the extracted values to.
 */
const preprocessTokensJson = (jPath = getSourceJsonPath()): string[] => {
    const tokens: DesignTokensFigma = JSON.parse(fs.readFileSync(jPath, "utf-8"));
    const { $metadata: { tokenSetOrder } } = tokens;
    const extractedThemes = extractThemes(tokenSetOrder, tokens);
    return extractedThemes.map(([key, data]) => writeToFile(JSON.stringify(data, null, 2), `${key}_theme`, getDirectoryPath(), 'json')).filter(Boolean) as string[];
}

/**
 * The generic header for generated files.
 * @returns string
 */
const createDoNotEditHeader = () => `/**
Do not edit directly
This file was generated by 'build-tokens.js' on
${new Date().toISOString()}
*/

`;

/* CUSTOM FORMATTERS FOR THE STYLE DICTIONARY */

const jsonExport = "typescript/customFormat";
const stylexExport = "javascript/customFormat";

StyleDictionary.registerFormat({
    name: jsonExport,
    formatter: function ({ dictionary }: FormatterArguments) {
        const { properties } = dictionary
        return `${createDoNotEditHeader()}
      export const tokens = ${JSON.stringify(properties, null, 2)};`;

    },
});

StyleDictionary.registerFormat({
    name: stylexExport,
    formatter: function ({ dictionary }: FormatterArguments) {
        const { properties } = dictionary
        return `${createDoNotEditHeader()}
      import * as stylex from '@stylexjs/stylex'; 
      export const tokens = stylex.defineVars(${JSON.stringify(properties, null, 2)});`;
    },
});

/* CUSTOM FORMATTERS FOR THE STYLE DICTIONARY ENDS */

type platformType = {
    transformGroup: string,
    prefix?: string,
    buildPath: string,
    files: { [key: string]: string }[]
}

type platformRecordType = Record<string, platformType>

type configType = {
    source: string[],
    preprocessors: string[],
    excludeParentKeys: boolean,
    platforms: platformRecordType
};

export const config: Config = {
    source: [getSourceJsonPath()],
    // preprocessors: ['tokens-studio'],
    // excludeParentKeys: true,
    platforms: {
        scss: {
            transformGroup: "scss",
            prefix: "rh",
            buildPath: getExportsDirectoryPath('theme', 'scss'),
            files: [
                {
                    destination: "_variables.scss",
                    format: "scss/variables",
                },
            ],
        },
        css: {
            transformGroup: "css",
            buildPath: getExportsDirectoryPath('theme', 'css'),
            files: [
                {
                    destination: "tokens.css",
                    format: "css/variables",
                },
            ],
        },
        js: {
            transformGroup: "js",
            buildPath: getExportsDirectoryPath('theme', 'js'),
            files: [
                {
                    destination: "tokens.js",
                    format: "javascript/es6",
                },
            ],
        },
        ts: {
            transformGroup: "js",
            buildPath: getExportsDirectoryPath('theme', 'ts'),
            files: [
                {
                    destination: "tokens.ts",
                    format: jsonExport,
                },
            ],
        },
        stylex: {
            transformGroup: "js",
            buildPath: getExportsDirectoryPath('theme', 'stylex'),
            files: [
                {
                    destination: "tokens.stylex.js",
                    format: stylexExport,
                },
            ],
        },
    },
};

export const createConfig = (baseConfig: Config, themeName: string, source: string[]): Config => {
    const { platforms } = baseConfig;
    let newPlatform = {...platforms};
    if (platforms) {
        const platformKeys = Object.keys(platforms);
        newPlatform = platformKeys.reduce((acc, current) => {
        const platform = platforms[current];
        return {
            ...acc,
            [current]: {
                ...platform,
                buildPath: getExportsDirectoryPath(removeSuffix(themeName), current)
            }
        }
        }, {});
    }

    return { ...baseConfig, source: source, platforms: newPlatform } as Config;
}


const execute = () => {
    const filePaths = preprocessTokensJson();
    filePaths.forEach((filePath) => {
        const scopedConfig = createConfig(config, path.basename(filePath), [filePath]);
        const styleDictionaryInstance = StyleDictionary.extend(scopedConfig);
        styleDictionaryInstance.cleanAllPlatforms();
        styleDictionaryInstance.buildAllPlatforms();
    });
}

execute();
